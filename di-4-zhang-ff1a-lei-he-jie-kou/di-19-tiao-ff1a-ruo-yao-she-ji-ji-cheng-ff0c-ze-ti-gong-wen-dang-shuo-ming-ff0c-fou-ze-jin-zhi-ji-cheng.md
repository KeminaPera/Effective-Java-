### 第19条：若要设计继承，则提供文档说明，否则禁止继承

Item 18 alerted you to the dangers of subclassing a “foreign” class that was not designed and documented for inheritance. So what does it mean for a class to be designed and documented for inheritance?

条目18提醒我们，对于并不是为了继承而设计同时又没有良好的说明文档的“外来”类，去子类化它是很危险的。那么，“为了继承而设计同时提供文档说明”到底意味着什么呢？

First, the class must document precisely the effects of overriding any method. In other words, **the class must document its self-use of overridable methods**. For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. \(By overridable, we mean nonfinal and either public or protected.\) More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.

首先，必须在这个类的文档里为每个方法说明覆盖带来的影响。换句话说，**必须在这个类的文档里为可覆盖方法说明它的自用性（self-use）。**对于每个公有方法或受保护方法，文档里都必须指明这个方法调用了哪些可覆盖方法，是以什么顺序调用的，每个调用的结果是如何影响接下来的处理过程。（可覆盖是指非final，公有的或受保护的。）说得更通俗点，一个类的文档必须说明在哪些情况下它会调用可覆盖方法。例如，调用可能来自后台线程或者静态初始器（static initializer）。

A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec. This section describes the inner workings of the method. Here’s an example, copied from the specification for java.util.AbstractCollection:

调用可覆盖方法的方法应当在文档注释的末尾包含这些调用的描述。这个描述是规范中的特定部分，标记为“Implementation Requirements”，这由Javadoc标签@implSpec生成。这部分描述了方法的内部运作过程。下面举个例子，拷贝自java.util.AbstractCollection的规范：

```
public boolean remove(Object o)
```

> Removes a single instance of the specified element from this collection, if it is present \(optional operation\). More formally, removes an element e such that Objects.equals\(o, e\), if this collection contains one or more such elements. Returns true if this collection contained the specified element \(or equivalently, if this collection changed as a result of the call\).
>
> **Implementation Requirements:**This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.
>
> 如果集合里存在指定元素对象，则将其从这个集合里移除（可选操作）。正式地说，如果这个集合包含一个或多个这样的元素，则将满足Objects.equals\(o, e\)的元素移除。如果这个集合包含指定的元素，则返回true（如果因调用而使集合改变了，也一样返回true）。
>
> **实现要求：**这个实现通过遍历集合来查找指定的元素。如果它找到这个元素，则使用迭代器的移除方法（remove method）将其从集合中移除。注意，如果集合的迭代器方法（iterator method）返回的迭代器没有实现移除方法同时集合也包含指定的对象的话，则这个将抛出UnsupportedOperationException异常。

This documentation leaves no doubt that overriding the iterator method will affect the behavior of the remove method. It also describes exactly how the behavior of the Iterator returned by the iterator method will affect the behavior of the remove method. Contrast this to the situation in Item 18, where the programmer subclassing HashSet simply could not say whether overriding the add method would affect the behavior of the addAll method. 

文档明确说明了覆盖迭代方法将会影响移除方法的行为。文档还明确描述了迭代方法返回的迭代器的行为会影响移除方法的行为。与条目18不同，在条目18里提到的案例中，程序员继承HashSet时不能说明覆盖了add方法是否会影响addAll方法的行为。

But doesn’t this violate the dictum that good API documentation should describe what a given method does and not how it does it? Yes, it does! This is an unfortunate consequence of the fact that inheritance violates encapsulation. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.

在编程界里有条名言：好的API文档应该是在描述方法是干什么的，而不是在说明它是如何做到的。这么说的话，那上面的文档岂不是违反了这条名言？是的，的确是。违反了封装是继承的一个无可奈何的副作用。为了让一个类可以被安全地继承，我们必须在文档里描述那些没有详细说明的实现细节。

The @implSpec tag was added in Java 8 and used heavily in Java 9. This tag should be enabled by default, but as of Java 9, the Javadoc utility still ignores it unless you pass the command line switch -tag "apiNote:a:API Note:".

@implSpec标签在Java 8里就已经被添加了，并且在Java 9得到大量使用。这个标签应该启用，但在Java 9中，Javadoc工具仍然忽视了它，除非你在命令行里输入开关命令：-tag"apiNot:a:API Note"。

Designing for inheritance involves more than just documenting patterns of self-use. To allow programmers to write efficient subclasses without undue pain, **a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods **or, in rare instances, protected fields. For example, consider the removeRange method from java.util.AbstractList:

继承的设计不仅仅只包含关于自用的文档。

```
protected void removeRange(int fromIndex, int toIndex)
```

> Removes from this list all of the elements whose index is between from Index, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left \(reduces their index\). This call shortens the list by\(toIndex - fromIndex\)elements. \(If toIndex == fromIndex, this operation has no effect.\)  
> This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.
>
> **Implementation Requirements:**This implementation gets a list iterator positioned before fromIndex and repeatedly calls List Iterator.next followed by ListIterator.remove, until the entire range has been removed. **Note:**
>
> **If List Iterator.remove requires linear time, this implementation requires quadratic time.**
>
> Parameters:
>
> fromIndex index of first element to be removed.
>
> toIndex index after last element to be removed.

This method is of no interest to end users of a List implementation.

It is provided solely to make it easy for subclasses to provide a

fast clear method on sublists. In the absence of

the removeRangemethod, subclasses would have to make do with

quadratic performance when the clear method was invoked on

sublists or rewrite the entire subList mechanism from scratch—not

an easy task!

