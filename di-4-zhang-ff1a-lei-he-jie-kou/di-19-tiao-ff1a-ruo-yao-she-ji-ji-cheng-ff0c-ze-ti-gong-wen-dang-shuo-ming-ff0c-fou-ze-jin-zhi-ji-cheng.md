### 第19条：若要设计继承，则提供文档说明，否则禁止继承

Item 18 alerted you to the dangers of subclassing a “foreign” class that was not designed and documented for inheritance. So what does it mean for a class to be designed and documented for inheritance?

条目18提醒我们，对于并不是为了继承而设计同时又没有良好的说明文档的“外来”类，去子类化它是很危险的。那么，“为了继承而设计同时提供文档说明”到底意味着什么呢？

First, the class must document precisely the effects of overriding any method. In other words, **the class must document its self-use of overridable methods**. For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. \(By overridable, we mean nonfinal and either public or protected.\) More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.

首先，必须在这个类的文档里为每个方法说明覆盖带来的影响。换句话说，**必须在这个类的文档里为可覆盖方法说明它的自用性（self-use）。**对于每个公有方法或受保护方法，文档里都必须指明这个方法调用了哪些可覆盖方法，是以什么顺序调用的，每个调用的结果是如何影响接下来的处理过程。（可覆盖是指非final，公有的或受保护的。）说得更通俗点，一个类的文档必须说明在哪些情况下它会调用可覆盖方法。例如，调用可能来自后台线程或者静态初始器（static initializer）。

A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec. This section describes the inner workings of the method. Here’s an example, copied from the specification for java.util.AbstractCollection:

调用可覆盖方法的方法应当在文档注释的末尾包含这些调用的描述。这个描述是规范中的特定部分，标记为“Implementation Requirements”，这由Javadoc标签@implSpec生成。这部分描述了方法的内部运作过程。下面举个例子，拷贝自java.util.AbstractCollection的规范：

```
public boolean remove(Object o)
```

> Removes a single instance of the specified element from this collection, if it is present \(optional operation\). More formally, removes an element e such that Objects.equals\(o, e\), if this collection contains one or more such elements. Returns true if this collection contained the specified element \(or equivalently, if this collection changed as a result of the call\).
>
> **Implementation Requirements:**This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement there move method and this collection contains the specified object.

> 如果集合里存在指定元素的一个对象，则将其从这个集合里移除（可选操作）。正式地说，如果这个集合包含一个或多个这样的元素，则将满足Objects.equals\(o, e\)的元素移除。如果这个集合包含指定的元素，则返回true（如果因调用而使集合改变了，也一样返回true）。
>
> **实现要求：**

This documentation leaves no doubt that overriding the iterator method will affect the behavior of there move method. It also describes exactly how the behavior of the Iterator returned by the iterator method will affect the behavior of the remove method. Contrast this to the situation inItem 18, where the programmer subclassing HashSet simply could not say whether overriding the add method would affect the behavior of the addAll method. But doesn’t this violate the dictum that good API documentation should describe what a given method does and not how it does it? Yes, it does! This is an unfortunate consequence of the fact that inheritance violates encapsulation. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.

The @implSpec tag was added in Java 8 and used heavily in Java 9. This tag should be enabled by default, but as of Java 9, the Javadoc utility still ignores it unless you pass the command line switch-tag "apiNote:a:API Note:".

Designing for inheritance involves more than just documenting patterns of self-use. To allow programmers to write efficient subclasses without undue pain, **a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods **or, in rare instances, protected fields. For example, consider the removeRange method from java.util.AbstractList:

```
protected void removeRange(int fromIndex, int toIndex)
```

Removes from this list all of the elements whose index is between from Index, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left \(reduces their index\). This call shortens the list by\(toIndex - fromIndex\)elements. \(If toIndex == fromIndex, this operation has no effect.\)  
This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.**Implementation Requirements:**This implementation gets a list iterator positioned before fromIndex and repeatedly calls List Iterator.next followed by ListIterator.remove, until the entire range has been removed. **Note:**

**If List Iterator.remove requires linear time, this implementation requires quadratic time.**

Parameters:

fromIndex index of first element to be removed.  
toIndex index after last element to be removed.

